{
  "lib/index.js": {
    "id": "lib/index.js",
    "type": "js",
    "mtime": 1400023962000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar Recurly = require('./recurly');\n\n/**\n * Export a single instance.\n */\n\nmodule.exports = exports = new Recurly();\n\n/**\n * Hack for testing.\n */\n\nexports.Recurly = Recurly;\n",
    "deps": {
      "./recurly": "lib/recurly.js"
    },
    "entry": true,
    "global": "recurly"
  },
  "lib/recurly.js": {
    "id": "lib/recurly.js",
    "type": "js",
    "mtime": 1413321400000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar bind = require('bind');\nvar json = require('json');\nvar each = require('each');\nvar type = require('type');\nvar merge = require('merge');\nvar mixin = require('mixin');\nvar jsonp = require('jsonp');\nvar qs = require('querystring');\nvar Emitter = require('emitter');\nvar errors = require('./errors');\nvar version = require('./version');\nvar debug = require('debug')('recurly');\n\n/**\n * Default configuration values.\n *\n * @private\n * @type {Object}\n */\n\nvar defaults = {\n    currency: 'USD'\n  , timeout: 60000\n  , publicKey: ''\n  , api: 'https://api.recurly.com/js/v1'\n};\n\n/**\n * Export `Recurly`.\n */\n\nmodule.exports = Recurly;\n\n/**\n * Initialize defaults.\n *\n * @param {Object} options\n * @constructor\n * @public\n */\n\nfunction Recurly (options) {\n  this.id = 0;\n  this.version = version;\n  this.configured = false;\n  this.config = merge({}, defaults);\n  if (options) this.configure(options);\n}\n\n/**\n * Inherits `Emitter`.\n */\n\nEmitter(Recurly.prototype);\n\n/**\n * Configure settings.\n *\n * @param {String|Object} options Either publicKey or object containing\n *                                publicKey and other optional members\n * @param {String} options.publicKey\n * @param {String} [options.currency]\n * @param {String} [options.api]\n * @public\n */\n\nRecurly.prototype.configure = function configure (options) {\n  if (this.configured) throw errors('already-configured');\n\n  debug('configure');\n\n  if (type(options) === 'string') options = { publicKey: options };\n\n  if ('publicKey' in options) {\n    this.config.publicKey = options.publicKey;\n  } else {\n    throw errors('missing-public-key');\n  }\n\n  if ('api' in options) {\n    this.config.api = options.api;\n  }\n\n  if ('currency' in options) {\n    this.config.currency = options.currency;\n  }\n\n  this.configured = true;\n};\n\n/**\n * Assembles the API endpoint.\n *\n * @return {String} route\n * @private\n */\n\nRecurly.prototype.url = function url (route) {\n  return this.config.api + route;\n};\n\n/**\n * Issues an API request.\n *\n * @param {String} route\n * @param {Object} [data]\n * @param {Function} done\n * @throws {Error} If `configure` has not been called.\n * @private\n */\n\nRecurly.prototype.request = function request (route, data, done) {\n  debug('request');\n\n  if (false === this.configured) {\n    throw errors('not-configured');\n  }\n\n  if ('function' == type(data)) {\n    done = data;\n    data = {};\n  }\n\n  var url = this.url(route);\n  var timeout = this.config.timeout;\n\n  data.version = this.version;\n  data.key = this.config.publicKey;\n\n  url += '?' + qs.stringify(data);\n\n  this.cache(url, function (res, set) {\n    if (res) return done(null, res);\n    jsonp(url, { timeout: timeout }, function (err, res) {\n      if (err) return done(err);\n      if (res.error) {\n        done(errors('api-error', res.error));\n      } else {\n        done(null, set(res));\n      }\n    });\n  });\n};\n\n/**\n * Caches an object\n *\n * TODO: figure out invalidation & expiry\n *\n * @param {String} url\n * @param {Function} done\n * @private\n */\n \nRecurly.prototype.cache = function cache (url, done) {\n  debug('cache');\n  var stored = localStorage.getItem(url);\n  if (stored) {\n    debug('cache found ' + url);\n    return done(json.parse(stored));\n  } else {\n    debug('cache set ' + url);\n    return done(null, set);\n  }\n  function set (obj) {\n    // disabled for now\n    // localStorage.setItem(url, json.stringify(obj));\n    return obj;\n  }\n};\n\nRecurly.prototype.open = require('./recurly/open');\nRecurly.prototype.relay = require('./recurly/relay');\nRecurly.prototype.coupon = require('./recurly/coupon');\nRecurly.prototype.paypal = require('./recurly/paypal');\nRecurly.prototype.plan = require('./recurly/plan');\nRecurly.prototype.tax = require('./recurly/tax');\nRecurly.prototype.token = require('./recurly/token');\nRecurly.prototype.validate = require('./recurly/validate');\nRecurly.prototype.Pricing = require('./recurly/pricing');\n",
    "deps": {
      "bind": "components/component-bind@0.0.1/index.js",
      "json": "components/component-json@0.0.2/index.js",
      "each": "components/component-each@0.2.3/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "merge": "components/yields-merge@1.0.0/index.js",
      "mixin": "components/kewah-mixin@0.1.0/index.js",
      "jsonp": "components/learnboost-jsonp@0.0.4/index.js",
      "querystring": "components/visionmedia-node-querystring@0.6.6/index.js",
      "emitter": "components/component-emitter@1.1.2/index.js",
      "./errors": "lib/errors.js",
      "./version": "lib/version.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js",
      "./recurly/open": "lib/recurly/open.js",
      "./recurly/relay": "lib/recurly/relay.js",
      "./recurly/coupon": "lib/recurly/coupon.js",
      "./recurly/paypal": "lib/recurly/paypal.js",
      "./recurly/plan": "lib/recurly/plan.js",
      "./recurly/tax": "lib/recurly/tax.js",
      "./recurly/token": "lib/recurly/token.js",
      "./recurly/validate": "lib/recurly/validate.js",
      "./recurly/pricing": "lib/recurly/pricing/index.js"
    }
  },
  "components/component-bind@0.0.1/index.js": {
    "id": "components/component-bind@0.0.1/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = [].slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n",
    "deps": {}
  },
  "components/component-type@1.0.0/index.js": {
    "id": "components/component-type@1.0.0/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * toString ref.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = function(val){\n  switch (toString.call(val)) {\n    case '[object Function]': return 'function';\n    case '[object Date]': return 'date';\n    case '[object RegExp]': return 'regexp';\n    case '[object Arguments]': return 'arguments';\n    case '[object Array]': return 'array';\n    case '[object String]': return 'string';\n  }\n\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (val && val.nodeType === 1) return 'element';\n  if (val === Object(val)) return 'object';\n\n  return typeof val;\n};\n",
    "deps": {}
  },
  "components/yields-merge@1.0.0/index.js": {
    "id": "components/yields-merge@1.0.0/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * merge `b`'s properties with `a`'s.\n *\n * example:\n *\n *        var user = {};\n *        merge(user, console);\n *        // > { log: fn, dir: fn ..}\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n */\n\nmodule.exports = function (a, b) {\n  for (var k in b) a[k] = b[k];\n  return a;\n};\n",
    "deps": {}
  },
  "components/kewah-mixin@0.1.0/index.js": {
    "id": "components/kewah-mixin@0.1.0/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "if (typeof Object.keys === 'function') {\n  module.exports = function(to, from) {\n    Object.keys(from).forEach(function(property) {\n      Object.defineProperty(to, property, Object.getOwnPropertyDescriptor(from, property));\n    });\n  };\n} else {\n  module.exports = function(to, from) {\n    for (var property in from) {\n      if (from.hasOwnProperty(property)) {\n        to[property] = from[property];\n      }\n    }\n  };\n}\n",
    "deps": {}
  },
  "components/visionmedia-node-querystring@0.6.6/index.js": {
    "id": "components/visionmedia-node-querystring@0.6.6/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Object#toString() ref for stringify().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Object#hasOwnProperty ref\n */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Array#indexOf shim.\n */\n\nvar indexOf = typeof Array.prototype.indexOf === 'function'\n  ? function(arr, el) { return arr.indexOf(el); }\n  : function(arr, el) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === el) return i;\n      }\n      return -1;\n    };\n\n/**\n * Array.isArray shim.\n */\n\nvar isArray = Array.isArray || function(arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/**\n * Object.keys shim.\n */\n\nvar objectKeys = Object.keys || function(obj) {\n  var ret = [];\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      ret.push(key);\n    }\n  }\n  return ret;\n};\n\n/**\n * Array#forEach shim.\n */\n\nvar forEach = typeof Array.prototype.forEach === 'function'\n  ? function(arr, fn) { return arr.forEach(fn); }\n  : function(arr, fn) {\n      for (var i = 0; i < arr.length; i++) fn(arr[i]);\n    };\n\n/**\n * Array#reduce shim.\n */\n\nvar reduce = function(arr, fn, initial) {\n  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);\n  var res = initial;\n  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);\n  return res;\n};\n\n/**\n * Cache non-integer test regexp.\n */\n\nvar isint = /^[0-9]+$/;\n\nfunction promote(parent, key) {\n  if (parent[key].length == 0) return parent[key] = {}\n  var t = {};\n  for (var i in parent[key]) {\n    if (hasOwnProperty.call(parent[key], i)) {\n      t[i] = parent[key][i];\n    }\n  }\n  parent[key] = t;\n  return t;\n}\n\nfunction parse(parts, parent, key, val) {\n  var part = parts.shift();\n  \n  // illegal\n  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;\n  \n  // end\n  if (!part) {\n    if (isArray(parent[key])) {\n      parent[key].push(val);\n    } else if ('object' == typeof parent[key]) {\n      parent[key] = val;\n    } else if ('undefined' == typeof parent[key]) {\n      parent[key] = val;\n    } else {\n      parent[key] = [parent[key], val];\n    }\n    // array\n  } else {\n    var obj = parent[key] = parent[key] || [];\n    if (']' == part) {\n      if (isArray(obj)) {\n        if ('' != val) obj.push(val);\n      } else if ('object' == typeof obj) {\n        obj[objectKeys(obj).length] = val;\n      } else {\n        obj = parent[key] = [parent[key], val];\n      }\n      // prop\n    } else if (~indexOf(part, ']')) {\n      part = part.substr(0, part.length - 1);\n      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);\n      parse(parts, obj, part, val);\n      // key\n    } else {\n      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);\n      parse(parts, obj, part, val);\n    }\n  }\n}\n\n/**\n * Merge parent key/val pair.\n */\n\nfunction merge(parent, key, val){\n  if (~indexOf(key, ']')) {\n    var parts = key.split('[')\n      , len = parts.length\n      , last = len - 1;\n    parse(parts, parent, 'base', val);\n    // optimize\n  } else {\n    if (!isint.test(key) && isArray(parent.base)) {\n      var t = {};\n      for (var k in parent.base) t[k] = parent.base[k];\n      parent.base = t;\n    }\n    set(parent.base, key, val);\n  }\n\n  return parent;\n}\n\n/**\n * Compact sparse arrays.\n */\n\nfunction compact(obj) {\n  if ('object' != typeof obj) return obj;\n\n  if (isArray(obj)) {\n    var ret = [];\n\n    for (var i in obj) {\n      if (hasOwnProperty.call(obj, i)) {\n        ret.push(obj[i]);\n      }\n    }\n\n    return ret;\n  }\n\n  for (var key in obj) {\n    obj[key] = compact(obj[key]);\n  }\n\n  return obj;\n}\n\n/**\n * Parse the given obj.\n */\n\nfunction parseObject(obj){\n  var ret = { base: {} };\n\n  forEach(objectKeys(obj), function(name){\n    merge(ret, name, obj[name]);\n  });\n\n  return compact(ret.base);\n}\n\n/**\n * Parse the given str.\n */\n\nfunction parseString(str){\n  var ret = reduce(String(str).split('&'), function(ret, pair){\n    var eql = indexOf(pair, '=')\n      , brace = lastBraceInKey(pair)\n      , key = pair.substr(0, brace || eql)\n      , val = pair.substr(brace || eql, pair.length)\n      , val = val.substr(indexOf(val, '=') + 1, val.length);\n\n    // ?foo\n    if ('' == key) key = pair, val = '';\n    if ('' == key) return ret;\n\n    return merge(ret, decode(key), decode(val));\n  }, { base: {} }).base;\n\n  return compact(ret);\n}\n\n/**\n * Parse the given query `str` or `obj`, returning an object.\n *\n * @param {String} str | {Object} obj\n * @return {Object}\n * @api public\n */\n\nexports.parse = function(str){\n  if (null == str || '' == str) return {};\n  return 'object' == typeof str\n    ? parseObject(str)\n    : parseString(str);\n};\n\n/**\n * Turn the given `obj` into a query string\n *\n * @param {Object} obj\n * @return {String}\n * @api public\n */\n\nvar stringify = exports.stringify = function(obj, prefix) {\n  if (isArray(obj)) {\n    return stringifyArray(obj, prefix);\n  } else if ('[object Object]' == toString.call(obj)) {\n    return stringifyObject(obj, prefix);\n  } else if ('string' == typeof obj) {\n    return stringifyString(obj, prefix);\n  } else {\n    return prefix + '=' + encodeURIComponent(String(obj));\n  }\n};\n\n/**\n * Stringify the given `str`.\n *\n * @param {String} str\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyString(str, prefix) {\n  if (!prefix) throw new TypeError('stringify expects an object');\n  return prefix + '=' + encodeURIComponent(str);\n}\n\n/**\n * Stringify the given `arr`.\n *\n * @param {Array} arr\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[' + i + ']'));\n  }\n  return ret.join('&');\n}\n\n/**\n * Stringify the given `obj`.\n *\n * @param {Object} obj\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyObject(obj, prefix) {\n  var ret = []\n    , keys = objectKeys(obj)\n    , key;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    if ('' == key) continue;\n    if (null == obj[key]) {\n      ret.push(encodeURIComponent(key) + '=');\n    } else {\n      ret.push(stringify(obj[key], prefix\n        ? prefix + '[' + encodeURIComponent(key) + ']'\n        : encodeURIComponent(key)));\n    }\n  }\n\n  return ret.join('&');\n}\n\n/**\n * Set `obj`'s `key` to `val` respecting\n * the weird and wonderful syntax of a qs,\n * where \"foo=bar&foo=baz\" becomes an array.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {String} val\n * @api private\n */\n\nfunction set(obj, key, val) {\n  var v = obj[key];\n  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;\n  if (undefined === v) {\n    obj[key] = val;\n  } else if (isArray(v)) {\n    v.push(val);\n  } else {\n    obj[key] = [v, val];\n  }\n}\n\n/**\n * Locate last brace in `str` within the key.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction lastBraceInKey(str) {\n  var len = str.length\n    , brace\n    , c;\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}\n\n/**\n * Decode `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction decode(str) {\n  try {\n    return decodeURIComponent(str.replace(/\\+/g, ' '));\n  } catch (err) {\n    return str;\n  }\n}\n",
    "deps": {}
  },
  "components/component-emitter@1.1.2/index.js": {
    "id": "components/component-emitter@1.1.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n",
    "deps": {}
  },
  "lib/version.js": {
    "id": "lib/version.js",
    "type": "js",
    "mtime": 1413252785000,
    "src": "\n/**\n * Current package/component version.\n */\n\nmodule.exports = '3.0.7';\n",
    "deps": {}
  },
  "components/visionmedia-debug@0.8.1/debug.js": {
    "id": "components/visionmedia-debug@0.8.1/debug.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n",
    "deps": {}
  },
  "components/component-json@0.0.2/index.js": {
    "id": "components/component-json@0.0.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\nmodule.exports = 'undefined' == typeof JSON\n  ? require('component-json-fallback')\n  : JSON;\n",
    "deps": {}
  },
  "components/component-each@0.2.3/index.js": {
    "id": "components/component-each@0.2.3/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Module dependencies.\n */\n\nvar type = require('type');\nvar toFunction = require('to-function');\n\n/**\n * HOP reference.\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Iterate the given `obj` and invoke `fn(val, i)`\n * in optional context `ctx`.\n *\n * @param {String|Array|Object} obj\n * @param {Function} fn\n * @param {Object} [ctx]\n * @api public\n */\n\nmodule.exports = function(obj, fn, ctx){\n  fn = toFunction(fn);\n  ctx = ctx || this;\n  switch (type(obj)) {\n    case 'array':\n      return array(obj, fn, ctx);\n    case 'object':\n      if ('number' == typeof obj.length) return array(obj, fn, ctx);\n      return object(obj, fn, ctx);\n    case 'string':\n      return string(obj, fn, ctx);\n  }\n};\n\n/**\n * Iterate string chars.\n *\n * @param {String} obj\n * @param {Function} fn\n * @param {Object} ctx\n * @api private\n */\n\nfunction string(obj, fn, ctx) {\n  for (var i = 0; i < obj.length; ++i) {\n    fn.call(ctx, obj.charAt(i), i);\n  }\n}\n\n/**\n * Iterate object keys.\n *\n * @param {Object} obj\n * @param {Function} fn\n * @param {Object} ctx\n * @api private\n */\n\nfunction object(obj, fn, ctx) {\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      fn.call(ctx, key, obj[key]);\n    }\n  }\n}\n\n/**\n * Iterate array-ish.\n *\n * @param {Array|Object} obj\n * @param {Function} fn\n * @param {Object} ctx\n * @api private\n */\n\nfunction array(obj, fn, ctx) {\n  for (var i = 0; i < obj.length; ++i) {\n    fn.call(ctx, obj[i], i);\n  }\n}\n",
    "deps": {
      "type": "components/component-type@1.0.0/index.js",
      "to-function": "components/component-to-function@2.0.0/index.js"
    }
  },
  "lib/errors.js": {
    "id": "lib/errors.js",
    "type": "js",
    "mtime": 1400023962000,
    "src": "/**\n * dependencies\n */\n\nvar mixin = require('mixin');\n\n/**\n * Export `errors`.\n */\n\nmodule.exports = exports = errors;\n\n/**\n * Error accessor.\n *\n * @param {String} name\n * @param {Object} options\n * @return {Error}\n */\n\nfunction errors (name, options) {\n  return errors.get(name, options);\n}\n\n/**\n * Defined errors.\n *\n * @type {Object}\n * @private\n */\n\nerrors.map = {};\n\n/**\n * Base url for documention.\n *\n * @type {String}\n * @private\n */\n\nerrors.baseURL = '';\n\n/**\n * Sets the `baseURL` for docs.\n *\n * @param {String} url\n * @public\n */\n\nerrors.doc = function (baseURL) {\n  errors.baseURL = baseURL;\n};\n\n/**\n * Gets errors defined by `name`.\n *\n * @param {String} name\n * @param {Object} context\n * @return {Error}\n * @public\n */\n\nerrors.get = function (name, context) {\n  if (!(name in errors.map)) {\n    throw new Error('invalid error');\n  } else {\n    return new errors.map[name](context);\n  }\n};\n\n/**\n * Registers an error defined by `name` with `config`.\n *\n * @param {String} name\n * @param {Object} config\n * @return {Error}\n * @public\n */\n\nerrors.add = function (name, config) {\n  config = config || {};\n\n  function RecurlyError (context) {\n    Error.call(this);\n\n    this.name = this.code = name;\n    this.message = config.message;\n    mixin(this, context || {});\n\n    if (config.help) {\n      this.help = errors.baseURL + config.help;\n      this.message += ' (need help? ' + this.help + ')';\n    }\n  };\n\n  RecurlyError.prototype = new Error();\n  return errors.map[name] = RecurlyError;\n};\n\n/**\n * Internal definations.\n *\n * TODO(gjohnson): open source this as a component\n * and move these out.\n */\n\nerrors.doc('https://docs.recurly.com/js');\n\nerrors.add('already-configured', {\n  message: 'Configuration may only be set once.',\n  help: '#identify-your-site'\n});\n\nerrors.add('not-configured', {\n  message: 'Not configured. You must first call recurly.configure().',\n  help: '#identify-your-site'\n});\n\nerrors.add('missing-public-key', {\n  message: 'The publicKey setting is required.',\n  help: '#identify-your-site'\n});\n\nerrors.add('api-error', {\n  message: 'There was an error with your request.'\n});\n\nerrors.add('validation', {\n  message: 'There was an error validating your request.'\n});\n\nerrors.add('missing-callback', {\n  message: 'Missing callback'\n});\n\nerrors.add('invalid-options', {\n  message: 'Options must be an object'\n});\n\nerrors.add('missing-plan', {\n  message: 'A plan must be specified.'\n});\n\nerrors.add('missing-coupon', {\n  message: 'A coupon must be specified.'\n});\n\nerrors.add('invalid-item', {\n  message: 'The given item does not appear to be a valid recurly plan, coupon, addon, or taxable address.'\n});\n\nerrors.add('invalid-addon', {\n  message: 'The given addon_code is not among the valid addons for the specified plan.'\n});\n\nerrors.add('invalid-currency', {\n  message: 'The given currency is not among the valid codes for the specified plan.'\n});\n\nerrors.add('unremovable-item', {\n  message: 'The given item cannot be removed.'\n});\n",
    "deps": {
      "mixin": "components/kewah-mixin@0.1.0/index.js"
    }
  },
  "lib/recurly/open.js": {
    "id": "lib/recurly/open.js",
    "type": "js",
    "mtime": 1413321379000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar type = require('type');\nvar qs = require('querystring');\nvar errors = require('../errors');\nvar debug = require('debug')('recurly:open');\n\n/**\n * expose\n */\n\nmodule.exports = open;\n\n/**\n * Issues an API request to a popup window.\n *\n * TODO(*): configurable window name?\n * TODO(*): configurable window properties?\n *\n * @param {String} url\n * @param {Object} [data]\n * @param {Function} [done]\n * @throws {Error} If `configure` has not been called.\n * @return {Window}\n * @private\n */\n\nfunction open (url, data, done) {\n  debug('open');\n  \n  if (false === this.configured) {\n    throw errors('not-configured');\n  }\n\n  if ('function' == type(data)) {\n    done = data;\n    data = {};\n  }\n\n  data = data || {};\n  data.version = this.version;\n  data.event = 'recurly-open-' + this.id++;\n  data.key = this.config.publicKey;\n  this.once(data.event, done);\n\n  if (!/^https?:\\/\\//.test(url)) url = this.url(url);\n  url += (~url.indexOf('?') ? '&' : '?') + qs.stringify(data);\n\n  this.relay(function () {\n    window.open(url);\n  });\n};\n",
    "deps": {
      "type": "components/component-type@1.0.0/index.js",
      "querystring": "components/visionmedia-node-querystring@0.6.6/index.js",
      "../errors": "lib/errors.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  },
  "lib/recurly/coupon.js": {
    "id": "lib/recurly/coupon.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar type = require('type');\nvar debug = require('debug')('recurly:coupon');\nvar errors = require('../errors');\n\n/**\n * expose\n */\n\nmodule.exports = coupon;\n\n/**\n * Coupon mixin.\n *\n * Retrieves coupon information for the `plan`. The `callback` signature\n * is `err, plan` where `err` may be a request or server error, and `plan`\n * is a representation of the requested plan.\n *\n * @param {Object} options\n * @param {Function} callback\n */\n\nfunction coupon (options, callback) {\n  debug('%j', options);\n\n  if ('function' !== type(callback)) {\n    throw errors('missing-callback');\n  }\n\n  if ('object' !== type(options)) {\n    throw errors('invalid-options');\n  }\n\n  if (!('plan' in options)) {\n    throw errors('missing-plan');\n  }\n\n  if (!('coupon' in options)) {\n    throw errors('missing-coupon');\n  }\n\n  this.request('/plans/' + options.plan + '/coupons/' + options.coupon, options, callback);\n};\n",
    "deps": {
      "type": "components/component-type@1.0.0/index.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js",
      "../errors": "lib/errors.js"
    }
  },
  "lib/recurly/paypal.js": {
    "id": "lib/recurly/paypal.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar debug = require('debug')('recurly:paypal');\n\n/**\n * expose\n */\n\nmodule.exports = paypal;\n\n/**\n * Paypal mixin.\n *\n * @param {Object} data\n * @param {Function} done callback\n */\n\nfunction paypal (data, done) {\n  debug('start');\n  this.open('/paypal/start', data, done);\n};\n",
    "deps": {
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  },
  "lib/recurly/plan.js": {
    "id": "lib/recurly/plan.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar type = require('type');\nvar debug = require('debug')('recurly:plan');\n\n/**\n * expose\n */\n\nmodule.exports = plan;\n\n/**\n * Plan mixin.\n *\n * Retrieves information for the `plan`. The `callback` signature\n * is `err, plan` where `err` may be a request or server error, and `plan`\n * is a representation of the requested plan.\n *\n * @param {String} code\n * @param {Function} callback\n */\n\nfunction plan (code, callback) {\n  debug('%s', code);\n\n  if ('function' != type(callback)) {\n    throw new Error('Missing callback');\n  }\n\n  if ('undefined' == type(code)) {\n    return callback(new Error('Missing plan code'));\n  }\n\n  this.request('/plans/' + code, callback);\n};\n",
    "deps": {
      "type": "components/component-type@1.0.0/index.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  },
  "lib/recurly/tax.js": {
    "id": "lib/recurly/tax.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar type = require('type');\nvar clone = require('clone');\nvar debug = require('debug')('recurly:tax');\n\n/**\n * expose\n */\n\nmodule.exports = tax;\n\n/**\n * Tax mixin.\n *\n * Provides a tax estiamte for the given address.\n *\n * @param {Object} options\n * @param {Object} options.postal_code\n * @param {Object} options.country\n * @param {Object} [options.vat_number] Used for VAT exemptions\n * @param {Function} callback\n */\n\nfunction tax (options, callback) {\n  var request = clone(options);\n\n  if ('function' != type(callback)) {\n    throw new Error('Missing callback');\n  }\n\n  if (!('currency' in request)) {\n    request.currency = this.config.currency;\n  }\n\n  this.request('/tax', request, callback);\n};\n",
    "deps": {
      "type": "components/component-type@1.0.0/index.js",
      "clone": "components/component-clone@0.2.2/index.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  },
  "lib/recurly/token.js": {
    "id": "lib/recurly/token.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar bind = require('bind');\nvar each = require('each');\nvar type = require('type');\nvar index = require('indexof');\nvar debug = require('debug')('recurly:token');\nvar dom = require('../util/dom');\nvar parseCard = require('../util/parse-card');\nvar errors = require('../errors');\n\n/**\n * expose\n */\n\nmodule.exports = token;\n\n/**\n * Fields that are sent to API.\n *\n * @type {Array}\n * @private\n */\n\nvar fields = [\n    'first_name'\n  , 'last_name'\n  , 'number'\n  , 'month'\n  , 'year'\n  , 'cvv'\n  , 'address1'\n  , 'address2'\n  , 'country'\n  , 'city'\n  , 'state'\n  , 'postal_code'\n  , 'phone'\n  , 'vat_number'\n  , 'token'\n];\n\n/**\n * Generates a token from customer data.\n *\n * The callback signature: `err, response` where `err` is a\n * connection, request, or server error, and `response` is the\n * recurly service response. The generated token is accessed\n * at `response.token`.\n *\n * @param {Object|HTMLFormElement} options Billing properties or an HTMLFormElement\n * with children corresponding to billing properties via 'data-reurly' attributes.\n * @param {String} options.first_name customer first name\n * @param {String} options.last_name customer last name\n * @param {String|Number} options.number card number\n * @param {String|Number} options.month card expiration month\n * @param {String|Number} options.year card expiration year\n * @param {String|Number} options.cvv card verification value\n * @param {String} [options.address1]\n * @param {String} [options.address2]\n * @param {String} [options.country]\n * @param {String} [options.city]\n * @param {String} [options.state]\n * @param {String|Number} [options.postal_code]\n * @param {Function} done callback\n */\n\nfunction token (options, done) {\n  var open = bind(this, this.open);\n  var data = normalize(options);\n  var input = data.values;\n  var userErrors = validate.call(this, input);\n\n  if ('function' !== type(done)) {\n    throw errors('missing-callback');\n  }\n\n  if (userErrors.length) {\n    return done(errors('validation', { fields: userErrors }));\n  }\n\n  this.request('/token', input, function (err, res) {\n    if (err) return done(err);\n    if (data.fields.token && res.id) {\n      data.fields.token.value = res.id;\n    }\n    done(null, res);\n  });\n};\n\n/**\n * Parses options out of a form element and normalizes according to rules.\n *\n * @param {Object|HTMLFormElement} options\n * @return {Object}\n */\n\nfunction normalize (options) {\n  var el = dom.element(options);\n  var data = { fields: {}, values: {} };\n\n  if (el && 'form' === el.nodeName.toLowerCase()) {\n    each(el.querySelectorAll('[data-recurly]'), function (field) {\n      var name = dom.data(field, 'recurly');\n      if (~index(fields, name)) {\n        data.fields[name] = field;\n        data.values[name] = dom.value(field);\n      }\n    });\n  } else {\n    data.values = options;\n  }\n\n  data.values.number = parseCard(data.values.number);\n\n  return data;\n}\n\n/**\n * Checks user input on a token call\n *\n * @param {Object} input\n * @return {Array} indicates which fields are not valid\n */\n\nfunction validate (input) {\n  var errors = [];\n\n  if (!this.validate.cardNumber(input.number)) {\n    errors.push('number');\n  }\n\n  if (!this.validate.expiry(input.month, input.year)) {\n    errors.push('month', 'year');\n  }\n\n  if (!input.first_name) {\n    errors.push('first_name');\n  }\n\n  if (!input.last_name) {\n    errors.push('last_name');\n  }\n\n  return errors;\n}\n",
    "deps": {
      "bind": "components/component-bind@0.0.1/index.js",
      "each": "components/component-each@0.2.3/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "indexof": "components/component-indexof@0.0.3/index.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js",
      "../util/dom": "lib/util/dom.js",
      "../util/parse-card": "lib/util/parse-card.js",
      "../errors": "lib/errors.js"
    }
  },
  "lib/recurly/validate.js": {
    "id": "lib/recurly/validate.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar find = require('find');\nvar trim = require('trim');\nvar index = require('indexof');\nvar parseCard = require('../util/parse-card');\n\n/**\n * Card patterns.\n *\n * @private\n */\n\nvar types = [\n  {\n    type: 'discover',\n    pattern: /^(6011|622|64[4-9]|65)/,\n    lengths: [16]\n  }\n  , {\n    type: 'master',\n    pattern: /^5[0-5]/,\n    lengths: [16]\n  }\n  , {\n    type: 'american_express',\n    pattern: /^3[47]/,\n    lengths: [15]\n  }\n  , {\n    type: 'visa',\n    pattern: /^4/,\n    lengths: [13, 16]\n  }\n  , {\n    type: 'jcb',\n    pattern: /^35[2-8]\\d/,\n    lengths: [16]\n  }\n  , {\n    type: 'diners_club',\n    pattern: /^(30[0-5]|309|36|3[89]|54|55|2014|2149)/,\n    lengths: [14]\n  }\n];\n\n/**\n * Validate mixin.\n *\n * @public\n */\n\nmodule.exports = {\n\n  /**\n   * Validates a credit card number via luhn algorithm.\n   *\n   * @param {Number|String} number The card number.\n   * @return {Boolean}\n   * @see https://sites.google.com/site/abapexamples/javascript/luhn-validation\n   */\n\n  cardNumber: function (number) {\n    var str = parseCard(number);\n    var ca, sum = 0, mul = 1;\n    var i = str.length;\n\n    while (i--) {\n      ca = parseInt(str.charAt(i), 10) * mul;\n      sum += ca - (ca > 9) * 9;\n      mul ^= 3;\n    }\n\n    return sum % 10 === 0 && sum > 0;\n  },\n\n  /**\n   * Returns the type of the card number as a string.\n   *\n   * TODO(chrissrogers): Maybe undefined instread of \"unknown\"?\n   *\n   * @param {Number|String} number The card number\n   * @return {String} card type\n   */\n\n  cardType: function (number) {\n    var str = parseCard(number);\n    var card = find(types, function (card) {\n      return card.pattern.test(str) && ~index(card.lengths, str.length);\n    });\n    return card && card.type || 'unknown';\n  },\n\n  /**\n   * Validates whether an expiry month is present or future.\n   *\n   * @param {Numer|String} month The 2 digit month\n   * @param {Numer|String} year The 2 or 4 digit year\n   * @return {Boolean}\n   */\n\n  expiry: function (month, year) {\n    month = parseInt(month, 10) - 1;\n    if (month < 0 || month > 11) return false;\n    year = parseInt(year, 10);\n    year += year < 100 ? 2000 : 0;\n\n    var expiry = new Date;\n    expiry.setYear(year);\n    expiry.setDate(1);\n    expiry.setHours(0);\n    expiry.setMinutes(0);\n    expiry.setSeconds(0);\n    expiry.setMonth(month + 1);\n    return new Date < expiry;\n  },\n\n  /**\n   * Validates whether a number looks like a cvv.\n   *\n   * e.g.: '123', '0321'\n   *\n   * @param {Number|String} number The card verification value\n   * @return {Boolean}\n   */\n\n  cvv: function (number) {\n    number = trim(number + '');\n    return /^\\d+$/.test(number) && (number.length === 3 || number.length === 4);\n  }\n\n};\n",
    "deps": {
      "find": "components/component-find@0.0.1/index.js",
      "trim": "components/component-trim@0.0.1/index.js",
      "indexof": "components/component-indexof@0.0.3/index.js",
      "../util/parse-card": "lib/util/parse-card.js"
    }
  },
  "lib/recurly/pricing/index.js": {
    "id": "lib/recurly/pricing/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * dependencies\n */\n\nvar Emitter = require('emitter');\nvar index = require('indexof');\nvar each = require('each');\nvar type = require('type');\nvar bind = require('bind');\nvar find = require('find');\nvar mixin = require('mixin');\nvar keys = require('object').keys;\nvar json = require('json');\nvar debug = require('debug')('recurly:pricing');\nvar PricingPromise = require('./promise');\nvar Calculations = require('./calculations');\nvar errors = require('../../errors');\n\n/**\n * expose\n */\n\nmodule.exports = Pricing;\n\n/**\n * Pricing\n *\n * @constructor\n * @param {Recurly} recurly\n * @public\n */\n\nfunction Pricing (recurly) {\n  if (this instanceof require('../../recurly')) return new Pricing(this);\n  this.recurly = recurly;\n  this.reset();\n}\n\nEmitter(Pricing.prototype);\n\n/**\n * Subscription properties\n */\n\nPricing.properties = [\n    'plan'\n  , 'addon'\n  , 'coupon'\n  , 'address'\n  , 'currency'\n];\n\n/**\n * Resets the pricing calculator\n *\n * @public\n */\n\nPricing.prototype.reset = function () {\n  this.items = {};\n  this.items.addons = [];\n  this.currency(this.recurly.config.currency);\n};\n\n/**\n * Removes an object from the pricing model\n *\n * example\n *\n *   .remove({ plan: 'plan_code' });\n *   .remove({ addon: 'addon_code' });\n *   .remove({ coupon: 'coupon_code' });\n *   .remove({ address: true }); // to remove without specifying a code\n *\n * @param {Object} opts\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.remove = function (opts, done) {\n  var self = this;\n  var item;\n  debug('remove');\n\n  return new PricingPromise(function (resolve, reject) {\n    var prop = keys(opts)[0];\n    var id = opts[prop];\n    if (!~index(Pricing.properties, prop)) return reject(errors('invalid-item'));\n    if (prop === 'addon') {\n      var pos = index(self.items.addons, findAddon(self.items.addons, { code: id }));\n      if (~pos) {\n        item = self.items.addons.splice(pos);\n      }\n    } else if (self.items[prop] && (id === self.items[prop].code || id === true)) {\n      item = self.items[prop]\n      delete self.items[prop];\n    } else {\n      return reject(errors('unremovable-item', {\n          type: prop\n        , id: id\n        , reason: 'does not exist on this pricing instance.'\n      }));\n    }\n  }, this).nodeify(done);\n};\n\n/**\n * Provides a subscription price estimate using current state\n *\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.reprice = function (done) {\n  var self = this;\n  debug('reprice');\n\n  return new PricingPromise(function (resolve, reject) {\n    if (!self.items.plan) return reject(errors('missing-plan'));\n\n    Calculations(self, function (price) {\n      if (json.stringify(price) === json.stringify(self.price)) return resolve(price);\n      self.price = price;\n      self.emit('change', price);\n      resolve(price);\n    });\n  }, this).nodeify(done);\n};\n\n/**\n * Updates plan\n *\n * @param {String} planCode\n * @param {Object} [meta]\n * @param {Number} [meta.quantity]\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.plan = function (planCode, meta, done) {\n  var self = this;\n  var plan = this.items.plan;\n  var quantity;\n\n  if (type(meta) === 'function') {\n    done = meta;\n    meta = undefined;\n  }\n\n  meta = meta || {};\n\n  // meta.quantity, plan.quantity, 1\n  if (plan && plan.quantity) quantity = plan.quantity;\n  if (meta.quantity) quantity = parseInt(meta.quantity, 10);\n  if (!quantity || quantity < 1) quantity = 1;\n\n  return new PricingPromise(function (resolve, reject) {\n    if (plan && plan.code === planCode) {\n      plan.quantity = quantity;\n      return resolve(plan);\n    }\n\n    self.recurly.plan(planCode, function (err, plan) {\n      if (err) return reject(err);\n\n      plan.quantity = quantity;\n      self.items.plan = plan;\n\n      if (!(self.items.currency in plan.price)) {\n        self.currency(keys(plan.price)[0]);\n      }\n\n      debug('set.plan');\n      self.emit('set.plan', plan);\n      resolve(plan);\n    });\n  }, this).nodeify(done);\n};\n\n/**\n * Updates addon\n *\n * @param {String} addonCode\n * @param {Object} [meta]\n * @param {Number} [meta.quantity]\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.addon = function (addonCode, meta, done) {\n  var self = this;\n\n  if (type(meta) === 'function') {\n    done = meta;\n    meta = undefined;\n  }\n\n  meta = meta || {};\n\n  return new PricingPromise(function (resolve, reject) {\n    if (!self.items.plan) return reject(errors('missing-plan'));\n\n    var planAddon = findAddon(self.items.plan.addons, addonCode);\n    if (!planAddon) {\n      return reject(errors('invalid-addon', {\n          planCode: self.items.plan.code\n        , addonCode: addonCode\n      }));\n    }\n\n    var quantity = addonQuantity(meta, planAddon);\n    var addon = findAddon(self.items.addons, addonCode);\n\n    if (quantity === 0) {\n      self.remove({ addon: addonCode });\n    }\n\n    if (addon) {\n      addon.quantity = quantity;\n    } else {\n      addon = json.parse(json.stringify(planAddon));\n      addon.quantity = quantity;\n      self.items.addons.push(addon);\n    }\n\n    debug('set.addon');\n    self.emit('set.addon', addon);\n    resolve(addon);\n  }, this).nodeify(done);\n};\n\n/**\n * Updates coupon\n *\n * @param {String} couponCode\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.coupon = function (couponCode, done) {\n  var self = this;\n  var coupon = this.items.coupon;\n\n  return new PricingPromise(function (resolve, reject) {\n    if (!self.items.plan) return reject(errors('missing-plan'));\n    if (coupon) {\n      if (coupon.code === couponCode) return resolve(coupon);\n      else self.remove({ coupon: coupon.code });\n    }\n    if (!couponCode) return resolve();\n\n    self.recurly.coupon({ plan: self.items.plan.code, coupon: couponCode }, function (err, coupon) {\n      if (err && err.code !== 'not_found') return reject(err);\n\n      self.items.coupon = coupon;\n\n      debug('set.coupon');\n      self.emit('set.coupon', coupon);\n      resolve(coupon);\n    });\n  }, this).nodeify(done);\n};\n\n/**\n * Updates address\n *\n * @param {Object} address\n * @param {String} address.country\n * @param {String|Number} address.postal_code\n * @param {String} address.vat_number\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.address = function (address, done) {\n  var self = this;\n\n  return new PricingPromise(function (resolve, reject) {\n    if (json.stringify(address) === json.stringify(self.items.address)) {\n      return resolve(self.items.address);\n    }\n\n    self.items.address = address;\n\n    debug('set.address');\n    self.emit('set.address', address);\n    resolve(address);\n  }, this).nodeify(done);\n};\n\n/**\n * Updates or retrieves currency code\n *\n * @param {String} code\n * @param {Function} [done] callback\n * @public\n */\n\nPricing.prototype.currency = function (code, done) {\n  var self = this;\n  var plan = this.items.plan\n  var currency = this.items.currency;\n\n  return new PricingPromise(function (resolve, reject) {\n    if (currency === code) return resolve(currency);\n    if (plan && !(code in plan.price)) {\n      return reject(errors('invalid-currency', {\n          currencyCode: code\n        , planCurrencies: keys(plan.price)\n      }));\n    }\n\n    self.items.currency = code;\n\n    debug('set.currency');\n    self.emit('set.currency', code);\n    resolve(code);\n  }, this).nodeify(done);\n};\n\n/**\n * DOM attachment mixin\n */\n\nmixin(Pricing.prototype, require('./attach'));\n\n/**\n * Utility functions\n */\n\nfunction addonQuantity (meta, planAddon) {\n  var qty = 1;\n  if ('quantity' in planAddon) qty = planAddon.quantity;\n  if ('quantity' in meta) qty = meta.quantity;\n  return parseInt(qty, 10) || 0;\n}\n\nfunction findAddon (addons, code) {\n  return addons && find(addons, { code: code });\n}\n",
    "deps": {
      "emitter": "components/component-emitter@1.1.2/index.js",
      "indexof": "components/component-indexof@0.0.3/index.js",
      "each": "components/component-each@0.2.3/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "bind": "components/component-bind@0.0.1/index.js",
      "find": "components/component-find@0.0.1/index.js",
      "mixin": "components/kewah-mixin@0.1.0/index.js",
      "object": "components/component-object@0.0.3/index.js",
      "json": "components/component-json@0.0.2/index.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js",
      "./promise": "lib/recurly/pricing/promise.js",
      "./calculations": "lib/recurly/pricing/calculations.js",
      "../../errors": "lib/errors.js",
      "../../recurly": "lib/recurly.js",
      "./attach": "lib/recurly/pricing/attach.js"
    }
  },
  "components/component-event@0.1.3/index.js": {
    "id": "components/component-event@0.1.3/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',\n    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n    prefix = bind !== 'addEventListener' ? 'on' : '';\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  el[bind](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};",
    "deps": {}
  },
  "components/component-indexof@0.0.3/index.js": {
    "id": "components/component-indexof@0.0.3/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "module.exports = function(arr, obj){\n  if (arr.indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};",
    "deps": {}
  },
  "lib/util/parse-card.js": {
    "id": "lib/util/parse-card.js",
    "type": "js",
    "mtime": 1400023962000,
    "src": "\n/**\n * Removes dashes and spaces from a card number.\n *\n * @param {Number|String} number\n * @return {String} parsed card number\n */\n\nmodule.exports = function parseCard (number) {\n  return number && number.toString().replace(/[-\\s]/g, '');\n};\n",
    "deps": {}
  },
  "components/component-trim@0.0.1/index.js": {
    "id": "components/component-trim@0.0.1/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\nexports = module.exports = trim;\n\nfunction trim(str){\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  if (str.trimLeft) return str.trimLeft();\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  if (str.trimRight) return str.trimRight();\n  return str.replace(/\\s*$/, '');\n};\n",
    "deps": {}
  },
  "components/component-object@0.0.3/index.js": {
    "id": "components/component-object@0.0.3/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * HOP ref.\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Return own keys in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.keys = Object.keys || function(obj){\n  var keys = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n  return keys;\n};\n\n/**\n * Return own values in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.values = function(obj){\n  var vals = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n};\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api public\n */\n\nexports.merge = function(a, b){\n  for (var key in b) {\n    if (has.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/**\n * Return length of `obj`.\n *\n * @param {Object} obj\n * @return {Number}\n * @api public\n */\n\nexports.length = function(obj){\n  return exports.keys(obj).length;\n};\n\n/**\n * Check if `obj` is empty.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api public\n */\n\nexports.isEmpty = function(obj){\n  return 0 == exports.length(obj);\n};",
    "deps": {}
  },
  "lib/util/dom.js": {
    "id": "lib/util/dom.js",
    "type": "js",
    "mtime": 1402203205000,
    "src": "/**\n * dependencies\n */\n\nvar slug = require('to-slug-case');\nvar type = require('type');\nvar each = require('each');\nvar map = require('map');\n\n/**\n * expose\n */\n\nmodule.exports = {\n  element: element,\n  value: value,\n  data: data\n};\n\n/**\n * Detects whether an object is an html element.\n *\n * @param {Mixed} node\n * @return {HTMLElement|Boolean} node\n */\n\nfunction element (node) {\n  var isJQuery = window.jQuery && node instanceof jQuery;\n  var isArray = type(node) === 'array';\n  if (isJQuery || isArray) node = node[0];\n\n  var isElem = typeof HTMLElement !== 'undefined'\n    ? node instanceof HTMLElement\n    : node && node.nodeType === 1;\n\n  return isElem && node;\n};\n\n/**\n * Gets or sets the value of a given HTML form element\n *\n * supports text inputs, radio inputs, and selects\n *\n * @param {HTMLElement} node\n * @return {String} value of the element\n */\n\nfunction value (node, value) {\n  if (!element(node)) return null;\n  return typeof value !== 'undefined'\n    ? valueSet(node, value)\n    : valueGet(node);\n}\n\n/**\n * Gets an HTMLElement's value property in the context of a form\n *\n * @param {HTMLElement} node\n * @return {String} node's value\n */\n\nfunction valueGet (node) {\n  node = element(node);\n\n  var nodeType = node && node.type && node.type.toLowerCase();\n  var value;\n\n  if (!nodeType) {\n    value = '';\n  } else if ('options' in node) {\n    value = node.options[node.selectedIndex].value;\n  } else if (nodeType === 'checkbox') {\n    if (node.checked) value = node.value;\n  } else if (nodeType === 'radio') {\n    var radios = document.querySelectorAll('input[data-recurly=\"' + data(node, 'recurly') + '\"]');\n    each(radios, function (radio) {\n      if (radio.checked) value = radio.value;\n    });\n  } else if ('value' in node) {\n    value = node.value;\n  }\n\n  return value;\n}\n\n/**\n * Updates an element's value property if\n * one exists; else innerText if it exists\n *\n * @param {Array[HTMLElement]} nodes\n * @param {Mixed} value\n */\n\nfunction valueSet (nodes, value) {\n  if (type(nodes) !== 'array') nodes = [nodes];\n  each(nodes, function (node) {\n    if (!node) return;\n    else if ('value' in node)\n      node.value = value;\n    else if ('textContent' in node)\n      node.textContent = value;\n    else if ('innerText' in node)\n      node.innerText = value;\n  });\n}\n\n/**\n * Gets or sets a node's data attribute\n *\n * @param {HTMLElement} node\n * @param {String} key\n * @param {Mixed} [value]\n */\n\nfunction data (node, key, value) {\n  node = element(node);\n  if (!node) return;\n  return typeof value !== 'undefined'\n    ? dataSet(node, key, value)\n    : dataGet(node, key);\n}\n\n/**\n * Gets a node's data attribute\n *\n * @param {HTMLElement} node\n * @param {String} key\n */\n\nfunction dataGet (node, key) {\n  return node.dataset\n    ? node.dataset[key]\n    : node.getAttribute('data-' + slug(key));\n}\n\n/**\n * sets a node's data attribute\n *\n * @param {HTMLElement} node\n * @param {String} key\n * @param {Mixed} value\n */\n\nfunction dataSet (node, key, value) {\n  if (node.dataset) node.dataset[key] = value;\n  else node.setAttribute('data-' + slug(key), value);\n}\n",
    "deps": {
      "to-slug-case": "components/ianstormtaylor-to-slug-case@0.1.2/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "each": "components/component-each@0.2.3/index.js",
      "map": "components/component-map@0.0.1/index.js"
    }
  },
  "lib/recurly/pricing/calculations.js": {
    "id": "lib/recurly/pricing/calculations.js",
    "type": "js",
    "mtime": 1413252861000,
    "src": "/**\n * dependencies\n */\n\nvar each = require('each');\nvar bind = require('bind');\nvar find = require('find');\n\n/**\n * expose\n */\n\nmodule.exports = Calculations;\n\n/**\n * Subscription calculation calculation\n *\n * @param {Pricing} pricing\n * @constructor\n * @public\n */\n\nfunction Calculations (pricing, done) {\n  if (!(this instanceof Calculations)) {\n    return new Calculations(pricing, done);\n  }\n\n  this.pricing = pricing;\n  this.items = pricing.items;\n\n  this.price = {\n    now: {},\n    next: {},\n    base: {\n      plan: {},\n      addons: {}\n    },\n    currency: {\n      code: this.items.currency,\n      symbol: this.planPrice().symbol\n    }\n  };\n\n  this.subtotal();\n\n  this.tax(function () {\n    this.total();\n    each(this.price.base.plan, decimal, this.price.base.plan);\n    each(this.price.base.addons, decimal, this.price.base.addons);\n    each(this.price.now, decimal, this.price.now);\n    each(this.price.next, decimal, this.price.next);\n    done(this.price);\n  });\n}\n\n/**\n * Calculates subtotal\n *\n * @private\n */\n\nCalculations.prototype.subtotal = function () {\n  this.price.now.subtotal = 0;\n  this.price.next.subtotal = 0;\n\n  this.plan();\n  this.price.now.subtotal += this.price.now.plan;\n  this.price.next.subtotal += this.price.next.plan;\n\n  this.addons();\n  this.price.now.subtotal += this.price.now.addons;\n  this.price.next.subtotal += this.price.next.addons;\n\n  this.discount();\n  this.price.now.subtotal -= this.price.now.discount;\n  this.price.next.subtotal -= this.price.next.discount;\n\n  this.setupFee();\n  this.price.now.subtotal += this.price.now.setup_fee;\n};\n\n/**\n * Calculates tax\n * \n * @param {Function} done\n * @private\n */\n\nCalculations.prototype.tax = function (done) {\n  this.price.now.tax = 0;\n  this.price.next.tax = 0;\n\n  if (this.items.address) {\n    var self = this;\n    this.pricing.recurly.tax(this.items.address, function applyTax (err, taxes) {\n      if (err) {\n        self.pricing.emit('error', err);\n      } else {\n        each(taxes, function (tax) {\n          if (tax.type === 'usst' && self.items.plan.tax_exempt) return;\n          self.price.now.tax += parseFloat((self.price.now.subtotal * tax.rate).toFixed(6));\n          self.price.next.tax += parseFloat((self.price.next.subtotal * tax.rate).toFixed(6));\n        });\n\n        // tax estimation prefers partial cents to always round up\n        self.price.now.tax = Math.ceil(self.price.now.tax * 100) / 100;\n        self.price.next.tax = Math.ceil(self.price.next.tax * 100) / 100;\n      }\n      done.call(self);\n    });\n  } else done.call(this);\n};\n\n/**\n * Calculates total\n *\n * @private\n */\n\nCalculations.prototype.total = function () {\n  this.price.now.total = this.price.now.subtotal + this.price.now.tax;\n  this.price.next.total = this.price.next.subtotal + this.price.next.tax;\n};\n\n/**\n * Computes plan prices\n *\n * @private\n */\n\nCalculations.prototype.plan = function () {\n  var base = this.items.plan.price[this.items.currency];\n  this.price.base.plan.unit = base.unit_amount;\n  this.price.base.plan.setup_fee = base.setup_fee;\n\n  var amount = this.planPrice().amount;\n  this.price.now.plan = amount;\n  this.price.next.plan = amount;\n\n  if (this.items.plan.trial) this.price.now.plan = 0;\n};\n\n/**\n * Computes addon prices and applies addons to the subtotal\n *\n * @private\n */\n\nCalculations.prototype.addons = function () {\n  this.price.now.addons = 0;\n  this.price.next.addons = 0;\n\n  each(this.items.plan.addons, function (addon) {\n    var price = addon.price[this.items.currency].unit_amount;\n\n    this.price.base.addons[addon.code] = price;\n\n    var selected = find(this.items.addons, { code: addon.code });\n    if (selected) {\n      price = price * selected.quantity;\n      if (!this.items.plan.trial) this.price.now.addons += price;\n      this.price.next.addons += price;\n    }\n  }, this);\n};\n\n/**\n * Applies coupon discount to the subtotal\n *\n * @private\n */\n\nCalculations.prototype.discount = function () {\n  var coupon = this.items.coupon;\n\n  this.price.now.discount = 0;\n  this.price.next.discount = 0;\n\n  if (coupon) {\n    if (coupon.discount.rate) {\n      var discountNow = parseFloat((this.price.now.subtotal * coupon.discount.rate).toFixed(6));\n      var discountNext = parseFloat((this.price.next.subtotal * coupon.discount.rate).toFixed(6));\n      this.price.now.discount = Math.round(discountNow * 100) / 100;\n      this.price.next.discount = Math.round(discountNext * 100) / 100;\n    } else {\n      this.price.now.discount = coupon.discount.amount[this.items.currency];\n      this.price.next.discount = coupon.discount.amount[this.items.currency];\n    }\n  }\n};\n\n/**\n * Applies plan setup fee to the subtotal\n *\n * @private\n */\n\nCalculations.prototype.setupFee = function () {\n  this.price.now.setup_fee = this.planPrice().setup_fee;\n  this.price.next.setup_fee = 0;\n};\n\n/**\n * Get the price structure of a plan based on currency\n *\n * @return {Object}\n * @private\n */\n\nCalculations.prototype.planPrice = function () {\n  var plan = this.items.plan;\n  var price = plan.price[this.items.currency];\n  price.amount = price.unit_amount * (plan.quantity || 1);\n  return price;\n};\n\n/**\n * Applies a decimal transform on an object's member\n *\n * @param {String} prop Property on {this} to transform\n * @this {Object} on which to apply decimal transformation\n * @private\n */\n\nfunction decimal (prop) {\n  this[prop] = (Math.round(Math.max(this[prop], 0) * 100) / 100).toFixed(2);\n}\n",
    "deps": {
      "each": "components/component-each@0.2.3/index.js",
      "bind": "components/component-bind@0.0.1/index.js",
      "find": "components/component-find@0.0.1/index.js"
    }
  },
  "lib/recurly/pricing/attach.js": {
    "id": "lib/recurly/pricing/attach.js",
    "type": "js",
    "mtime": 1413252861000,
    "src": "/**\n * dependencies\n */\n\nvar each = require('each');\nvar events = require('event');\nvar find = require('find');\nvar type = require('type');\nvar dom = require('../../util/dom');\nvar debug = require('debug')('recurly:pricing:attach');\n\n/**\n * bind a dom element to pricing values\n *\n * @param {HTMLElement} el\n */\n\nexports.attach = function (el) {\n  var self = this;\n  var elems = {};\n  var el = dom.element(el);\n\n  if (!el) throw new Error('invalid dom element');\n\n  if (this.attach.detatch) this.attach.detatch();\n\n  self.on('change', update);\n\n  each(el.querySelectorAll('[data-recurly]'), function (elem) {\n    // 'zip' -> 'postal_code'\n    if (dom.data(elem, 'recurly') === 'zip') dom.data(elem, 'recurly', 'postal_code');\n\n    var name = dom.data(elem, 'recurly');\n    if (!elems[name]) elems[name] = [];\n    elems[name].push(elem);\n    events.bind(elem, 'change', change);\n    events.bind(elem, 'propertychange', change);\n  });\n\n  this.attach.detatch = detatch;\n\n  change();\n\n  function change (event) {\n    debug('change');\n\n    var targetName = event && event.target && dom.data(event.target, 'recurly');\n        targetName = targetName || window.event && window.event.srcElement;\n\n    var pricing = self.plan(dom.value(elems.plan), { quantity: dom.value(elems.plan_quantity) });\n    \n    if (target('currency')) {\n      pricing = pricing.currency(dom.value(elems.currency));\n    }\n\n    if (target('addon') && elems.addon) {\n      addons();\n    }\n\n    if (target('coupon') && elems.coupon) {\n      pricing = pricing.coupon(dom.value(elems.coupon)).then(null, ignoreBadCoupons);\n    }\n\n    if (target('country') || target('postal_code') || target('vat_number')) {\n      pricing = pricing.address({\n        country: dom.value(elems.country),\n        postal_code: dom.value(elems.postal_code),\n        vat_number: dom.value(elems.vat_number)\n      });\n    }\n\n    pricing.done();\n\n    function addons () {\n      each(elems.addon, function (node) {\n        var plan = self.items.plan;\n        var addonCode = dom.data(node, 'recurlyAddon');\n        if (plan.addons && find(plan.addons, { code: addonCode })) {\n          pricing = pricing.addon(addonCode, { quantity: dom.value(node) });\n        }\n      });\n    }\n\n    function target (name) {\n      if (!targetName) return true;\n      if (targetName === name) return true;\n      return false\n    }\n  };\n\n  function update (price) {\n    dom.value(elems.currency_code, price.currency.code);\n    dom.value(elems.currency_symbol, price.currency.symbol);\n\n    dom.value(elems.plan_base, price.base.plan.unit);\n\n    each(['plan', 'addons', 'discount', 'setup_fee', 'subtotal', 'tax', 'total'], function (value) {\n      dom.value(elems[value + '_now'], price.now[value]);\n      dom.value(elems[value + '_next'], price.next[value]);\n    });\n\n    if (elems.addon_price) {\n      each(elems.addon_price, function (elem) {\n        var addonPrice = price.base.addons[dom.data(elem, 'recurlyAddon')];\n        if (addonPrice) dom.value(elem, addonPrice);\n      });\n    }\n  }\n\n  function detatch () {\n    each(elems, function (name, elems) {\n      each(elems, function (elem) {\n        events.unbind(elem, 'change', change);\n        events.unbind(elem, 'propertychange', change);\n      }, this);\n    }, this);\n  }\n};\n\nfunction ignoreBadCoupons (err) {\n  if (err.code === 'not-found') return;\n  else throw err;\n}\n\n/**\n * Backward-compatibility\n *\n * @deprecated\n */\n\nexports.binding = exports.attach;\n",
    "deps": {
      "each": "components/component-each@0.2.3/index.js",
      "event": "components/component-event@0.1.3/index.js",
      "find": "components/component-find@0.0.1/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "../../util/dom": "lib/util/dom.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  },
  "components/ianstormtaylor-to-slug-case@0.1.2/index.js": {
    "id": "components/ianstormtaylor-to-slug-case@0.1.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\nvar toSpace = require('to-space-case');\n\n\n/**\n * Expose `toSlugCase`.\n */\n\nmodule.exports = toSlugCase;\n\n\n/**\n * Convert a `string` to slug case.\n *\n * @param {String} string\n * @return {String}\n */\n\n\nfunction toSlugCase (string) {\n  return toSpace(string).replace(/\\s/g, '-');\n}",
    "deps": {
      "to-space-case": "components/ianstormtaylor-to-space-case@0.1.2/index.js"
    }
  },
  "components/ianstormtaylor-to-space-case@0.1.2/index.js": {
    "id": "components/ianstormtaylor-to-space-case@0.1.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\nvar clean = require('to-no-case');\n\n\n/**\n * Expose `toSpaceCase`.\n */\n\nmodule.exports = toSpaceCase;\n\n\n/**\n * Convert a `string` to space case.\n *\n * @param {String} string\n * @return {String}\n */\n\n\nfunction toSpaceCase (string) {\n  return clean(string).replace(/[\\W_]+(.|$)/g, function (matches, match) {\n    return match ? ' ' + match : '';\n  });\n}",
    "deps": {
      "to-no-case": "components/ianstormtaylor-to-no-case@0.1.0/index.js"
    }
  },
  "components/ianstormtaylor-to-no-case@0.1.0/index.js": {
    "id": "components/ianstormtaylor-to-no-case@0.1.0/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Expose `toNoCase`.\n */\n\nmodule.exports = toNoCase;\n\n\n/**\n * Test whether a string is camel-case.\n */\n\nvar hasSpace = /\\s/;\nvar hasCamel = /[a-z][A-Z]/;\nvar hasSeparator = /[\\W_]/;\n\n\n/**\n * Remove any starting case from a `string`, like camel or snake, but keep\n * spaces and punctuation that may be important otherwise.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction toNoCase (string) {\n  if (hasSpace.test(string)) return string.toLowerCase();\n\n  if (hasSeparator.test(string)) string = unseparate(string);\n  if (hasCamel.test(string)) string = uncamelize(string);\n  return string.toLowerCase();\n}\n\n\n/**\n * Separator splitter.\n */\n\nvar separatorSplitter = /[\\W_]+(.|$)/g;\n\n\n/**\n * Un-separate a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction unseparate (string) {\n  return string.replace(separatorSplitter, function (m, next) {\n    return next ? ' ' + next : '';\n  });\n}\n\n\n/**\n * Camelcase splitter.\n */\n\nvar camelSplitter = /(.)([A-Z]+)/g;\n\n\n/**\n * Un-camelcase a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction uncamelize (string) {\n  return string.replace(camelSplitter, function (m, previous, uppers) {\n    return previous + ' ' + uppers.toLowerCase().split('').join(' ');\n  });\n}",
    "deps": {}
  },
  "components/component-find@0.0.1/index.js": {
    "id": "components/component-find@0.0.1/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Module dependencies.\n */\n\nvar toFunction = require('to-function');\n\n/**\n * Find the first value in `arr` with when `fn(val, i)` is truthy.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n * @api public\n */\n\nmodule.exports = function(arr, fn){\n  // callback\n  if ('function' != typeof fn) {\n    if (Object(fn) === fn) fn = objectToFunction(fn);\n    else fn = toFunction(fn);\n  }\n\n  // filter\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (fn(arr[i], i)) return arr[i];\n  }\n};\n\n/**\n * Convert `obj` into a match function.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nfunction objectToFunction(obj) {\n  return function(o){\n    for (var key in obj) {\n      if (o[key] != obj[key]) return false;\n    }\n    return true;\n  }\n}",
    "deps": {
      "to-function": "components/component-to-function@2.0.5/index.js"
    }
  },
  "components/component-to-function@2.0.0/index.js": {
    "id": "components/component-to-function@2.0.0/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Module Dependencies\n */\n\nvar expr = require('props');\n\n/**\n * Expose `toFunction()`.\n */\n\nmodule.exports = toFunction;\n\n/**\n * Convert `obj` to a `Function`.\n *\n * @param {Mixed} obj\n * @return {Function}\n * @api private\n */\n\nfunction toFunction(obj) {\n  switch ({}.toString.call(obj)) {\n    case '[object Object]':\n      return objectToFunction(obj);\n    case '[object Function]':\n      return obj;\n    case '[object String]':\n      return stringToFunction(obj);\n    case '[object RegExp]':\n      return regexpToFunction(obj);\n    default:\n      return defaultToFunction(obj);\n  }\n}\n\n/**\n * Default to strict equality.\n *\n * @param {Mixed} val\n * @return {Function}\n * @api private\n */\n\nfunction defaultToFunction(val) {\n  return function(obj){\n    return val === obj;\n  }\n}\n\n/**\n * Convert `re` to a function.\n *\n * @param {RegExp} re\n * @return {Function}\n * @api private\n */\n\nfunction regexpToFunction(re) {\n  return function(obj){\n    return re.test(obj);\n  }\n}\n\n/**\n * Convert property `str` to a function.\n *\n * @param {String} str\n * @return {Function}\n * @api private\n */\n\nfunction stringToFunction(str) {\n  // immediate such as \"> 20\"\n  if (/^ *\\W+/.test(str)) return new Function('_', 'return _ ' + str);\n\n  // properties such as \"name.first\" or \"age > 18\" or \"age > 18 && age < 36\"\n  return new Function('_', 'return ' + get(str));\n}\n\n/**\n * Convert `object` to a function.\n *\n * @param {Object} object\n * @return {Function}\n * @api private\n */\n\nfunction objectToFunction(obj) {\n  var match = {}\n  for (var key in obj) {\n    match[key] = typeof obj[key] === 'string'\n      ? defaultToFunction(obj[key])\n      : toFunction(obj[key])\n  }\n  return function(val){\n    if (typeof val !== 'object') return false;\n    for (var key in match) {\n      if (!(key in val)) return false;\n      if (!match[key](val[key])) return false;\n    }\n    return true;\n  }\n}\n\n/**\n * Built the getter function. Supports getter style functions\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction get(str) {\n  var props = expr(str);\n  if (!props.length) return '_.' + str;\n\n  var val;\n  for(var i = 0, prop; prop = props[i]; i++) {\n    val = '_.' + prop;\n    val = \"('function' == typeof \" + val + \" ? \" + val + \"() : \" + val + \")\";\n    str = str.replace(new RegExp(prop, 'g'), val);\n  }\n\n  return str;\n}\n",
    "deps": {
      "props": "components/component-props@1.1.2/index.js"
    }
  },
  "components/component-props@1.1.2/index.js": {
    "id": "components/component-props@1.1.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Global Names\n */\n\nvar globals = /\\b(this|Array|Date|Object|Math|JSON)\\b/g;\n\n/**\n * Return immediate identifiers parsed from `str`.\n *\n * @param {String} str\n * @param {String|Function} map function or prefix\n * @return {Array}\n * @api public\n */\n\nmodule.exports = function(str, fn){\n  var p = unique(props(str));\n  if (fn && 'string' == typeof fn) fn = prefixed(fn);\n  if (fn) return map(str, p, fn);\n  return p;\n};\n\n/**\n * Return immediate identifiers in `str`.\n *\n * @param {String} str\n * @return {Array}\n * @api private\n */\n\nfunction props(str) {\n  return str\n    .replace(/\\.\\w+|\\w+ *\\(|\"[^\"]*\"|'[^']*'|\\/([^/]+)\\//g, '')\n    .replace(globals, '')\n    .match(/[$a-zA-Z_]\\w*/g)\n    || [];\n}\n\n/**\n * Return `str` with `props` mapped with `fn`.\n *\n * @param {String} str\n * @param {Array} props\n * @param {Function} fn\n * @return {String}\n * @api private\n */\n\nfunction map(str, props, fn) {\n  var re = /\\.\\w+|\\w+ *\\(|\"[^\"]*\"|'[^']*'|\\/([^/]+)\\/|[a-zA-Z_]\\w*/g;\n  return str.replace(re, function(_){\n    if ('(' == _[_.length - 1]) return fn(_);\n    if (!~props.indexOf(_)) return _;\n    return fn(_);\n  });\n}\n\n/**\n * Return unique array.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nfunction unique(arr) {\n  var ret = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (~ret.indexOf(arr[i])) continue;\n    ret.push(arr[i]);\n  }\n\n  return ret;\n}\n\n/**\n * Map with prefix `str`.\n */\n\nfunction prefixed(str) {\n  return function(_){\n    return str + _;\n  };\n}\n",
    "deps": {}
  },
  "components/component-to-function@2.0.5/index.js": {
    "id": "components/component-to-function@2.0.5/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Module Dependencies\n */\n\nvar expr;\ntry {\n  expr = require('props');\n} catch(e) {\n  expr = require('component-props');\n}\n\n/**\n * Expose `toFunction()`.\n */\n\nmodule.exports = toFunction;\n\n/**\n * Convert `obj` to a `Function`.\n *\n * @param {Mixed} obj\n * @return {Function}\n * @api private\n */\n\nfunction toFunction(obj) {\n  switch ({}.toString.call(obj)) {\n    case '[object Object]':\n      return objectToFunction(obj);\n    case '[object Function]':\n      return obj;\n    case '[object String]':\n      return stringToFunction(obj);\n    case '[object RegExp]':\n      return regexpToFunction(obj);\n    default:\n      return defaultToFunction(obj);\n  }\n}\n\n/**\n * Default to strict equality.\n *\n * @param {Mixed} val\n * @return {Function}\n * @api private\n */\n\nfunction defaultToFunction(val) {\n  return function(obj){\n    return val === obj;\n  };\n}\n\n/**\n * Convert `re` to a function.\n *\n * @param {RegExp} re\n * @return {Function}\n * @api private\n */\n\nfunction regexpToFunction(re) {\n  return function(obj){\n    return re.test(obj);\n  };\n}\n\n/**\n * Convert property `str` to a function.\n *\n * @param {String} str\n * @return {Function}\n * @api private\n */\n\nfunction stringToFunction(str) {\n  // immediate such as \"> 20\"\n  if (/^ *\\W+/.test(str)) return new Function('_', 'return _ ' + str);\n\n  // properties such as \"name.first\" or \"age > 18\" or \"age > 18 && age < 36\"\n  return new Function('_', 'return ' + get(str));\n}\n\n/**\n * Convert `object` to a function.\n *\n * @param {Object} object\n * @return {Function}\n * @api private\n */\n\nfunction objectToFunction(obj) {\n  var match = {};\n  for (var key in obj) {\n    match[key] = typeof obj[key] === 'string'\n      ? defaultToFunction(obj[key])\n      : toFunction(obj[key]);\n  }\n  return function(val){\n    if (typeof val !== 'object') return false;\n    for (var key in match) {\n      if (!(key in val)) return false;\n      if (!match[key](val[key])) return false;\n    }\n    return true;\n  };\n}\n\n/**\n * Built the getter function. Supports getter style functions\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction get(str) {\n  var props = expr(str);\n  if (!props.length) return '_.' + str;\n\n  var val, i, prop;\n  for (i = 0; i < props.length; i++) {\n    prop = props[i];\n    val = '_.' + prop;\n    val = \"('function' == typeof \" + val + \" ? \" + val + \"() : \" + val + \")\";\n\n    // mimic negative lookbehind to avoid problems with nested properties\n    str = stripNested(prop, str, val);\n  }\n\n  return str;\n}\n\n/**\n * Mimic negative lookbehind to avoid problems with nested properties.\n *\n * See: http://blog.stevenlevithan.com/archives/mimic-lookbehind-javascript\n *\n * @param {String} prop\n * @param {String} str\n * @param {String} val\n * @return {String}\n * @api private\n */\n\nfunction stripNested (prop, str, val) {\n  return str.replace(new RegExp('(\\\\.)?' + prop, 'g'), function($0, $1) {\n    return $1 ? $0 : val;\n  });\n}\n",
    "deps": {
      "props": "components/component-props@1.1.2/index.js",
      "component-props": "components/component-props@1.1.2/index.js"
    }
  },
  "components/component-map@0.0.1/index.js": {
    "id": "components/component-map@0.0.1/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * Module dependencies.\n */\n\nvar toFunction = require('to-function');\n\n/**\n * Map the given `arr` with callback `fn(val, i)`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n * @api public\n */\n\nmodule.exports = function(arr, fn){\n  var ret = [];\n  fn = toFunction(fn);\n  for (var i = 0; i < arr.length; ++i) {\n    ret.push(fn(arr[i], i));\n  }\n  return ret;\n};",
    "deps": {
      "to-function": "components/component-to-function@2.0.5/index.js"
    }
  },
  "components/component-clone@0.2.2/index.js": {
    "id": "components/component-clone@0.2.2/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Module dependencies.\n */\n\nvar type;\ntry {\n  type = require('component-type');\n} catch (_) {\n  type = require('type');\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = clone;\n\n/**\n * Clones objects.\n *\n * @param {Mixed} any object\n * @api public\n */\n\nfunction clone(obj){\n  switch (type(obj)) {\n    case 'object':\n      var copy = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          copy[key] = clone(obj[key]);\n        }\n      }\n      return copy;\n\n    case 'array':\n      var copy = new Array(obj.length);\n      for (var i = 0, l = obj.length; i < l; i++) {\n        copy[i] = clone(obj[i]);\n      }\n      return copy;\n\n    case 'regexp':\n      // from millermedeiros/amd-utils - MIT\n      var flags = '';\n      flags += obj.multiline ? 'm' : '';\n      flags += obj.global ? 'g' : '';\n      flags += obj.ignoreCase ? 'i' : '';\n      return new RegExp(obj.source, flags);\n\n    case 'date':\n      return new Date(obj.getTime());\n\n    default: // string, number, boolean, \n      return obj;\n  }\n}\n",
    "deps": {
      "component-type": "components/component-type@1.0.0/index.js",
      "type": "components/component-type@1.0.0/index.js"
    }
  },
  "components/learnboost-jsonp@0.0.4/index.js": {
    "id": "components/learnboost-jsonp@0.0.4/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Module dependencies\n */\n\nvar debug = require('debug')('jsonp');\n\n/**\n * Module exports.\n */\n\nmodule.exports = jsonp;\n\n/**\n * Callback index.\n */\n\nvar count = 0;\n\n/**\n * Noop function.\n */\n\nfunction noop(){}\n\n/**\n * JSONP handler\n *\n * Options:\n *  - param {String} qs parameter (`callback`)\n *  - timeout {Number} how long after a timeout error is emitted (`60000`)\n *\n * @param {String} url\n * @param {Object|Function} optional options / callback\n * @param {Function} optional callback\n */\n\nfunction jsonp(url, opts, fn){\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = {};\n  }\n  if (!opts) opts = {};\n\n  var prefix = opts.prefix || '__jp';\n  var param = opts.param || 'callback';\n  var timeout = null != opts.timeout ? opts.timeout : 60000;\n  var enc = encodeURIComponent;\n  var target = document.getElementsByTagName('script')[0] || document.head;\n  var script;\n  var timer;\n\n  // generate a unique id for this request\n  var id = prefix + (count++);\n\n  if (timeout) {\n    timer = setTimeout(function(){\n      cleanup();\n      if (fn) fn(new Error('Timeout'));\n    }, timeout);\n  }\n\n  function cleanup(){\n    script.parentNode.removeChild(script);\n    window[id] = noop;\n  }\n\n  window[id] = function(data){\n    debug('jsonp got', data);\n    if (timer) clearTimeout(timer);\n    cleanup();\n    if (fn) fn(null, data);\n  };\n\n  // add qs component\n  url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc(id);\n  url = url.replace('?&', '?');\n\n  debug('jsonp req \"%s\"', url);\n\n  // create script\n  script = document.createElement('script');\n  script.src = url;\n  target.parentNode.insertBefore(script, target);\n}\n",
    "deps": {
      "debug": "components/visionmedia-debug@2.0.0/browser.js"
    }
  },
  "components/visionmedia-debug@2.0.0/browser.js": {
    "id": "components/visionmedia-debug@2.0.0/browser.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // This hackery is required for IE8,\n  // where the `console.log` function doesn't have 'apply'\n  return 'object' == typeof console\n    && 'function' == typeof console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      localStorage.removeItem('debug');\n    } else {\n      localStorage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = localStorage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n",
    "deps": {
      "./debug": "components/visionmedia-debug@2.0.0/debug.js"
    }
  },
  "components/visionmedia-debug@2.0.0/debug.js": {
    "id": "components/visionmedia-debug@2.0.0/debug.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n",
    "deps": {
      "ms": "components/guille-ms.js@0.6.1/index.js"
    }
  },
  "components/guille-ms.js@0.6.1/index.js": {
    "id": "components/guille-ms.js@0.6.1/index.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n",
    "deps": {}
  },
  "lib/recurly/pricing/promise.js": {
    "id": "lib/recurly/pricing/promise.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/**\n * Dependencies\n */\n\nvar Promise = require('promise');\nvar mixin = require('mixin');\nvar bind = require('bind');\nvar each = require('each');\nvar type = require('type');\nvar par = require('par');\nvar debug = require('debug')('recurly:pricing:promise');\n\n/**\n * Expose\n */\n\nmodule.exports = PricingPromise;\n\n/**\n * PricingPromise\n *\n * issues repricing when .done\n *\n * contains .then wrappers for Pricing property methods\n *\n * Usage\n *\n *   var pricing = recurly.Pricing();\n *   \n *   pricing\n *     .plan('basic')\n *     .addon('addon1')\n *     .then(process)\n *     .catch(errors)\n *     .done();\n *\n * @param {Function} resolver\n * @param {Pricing} pricing bound instance\n * @constructor\n * @public\n */\n\nfunction PricingPromise (resolver, pricing) {\n  if (!(this instanceof PricingPromise)) return new PricingPromise(resolver, pricing);\n\n  var self = this;\n  this.pricing = pricing;\n  this.constructor = par.rpartial(this.constructor, pricing);\n\n  Promise.call(this, resolver);\n\n  // for each pricing method, create a promise wrapper method\n  each(require('./').prototype, function (method) {\n    self[method] = function () {\n      var args = arguments;\n      return self.then(function () {\n        return self.pricing[method].apply(self.pricing, args);\n      });\n    };\n  });\n}\n\nmixin(PricingPromise.prototype, Promise.prototype);\nPricingPromise.prototype.constructor = PricingPromise;\n\n/**\n * Adds a reprice and completes the control flow\n *\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n * @return {Pricing} bound pricing instance\n * @public\n */\n\nPricingPromise.prototype.done = function () {\n  Promise.prototype.done.apply(this.then(this.reprice), arguments);\n  return this.pricing;\n};\n\n/**\n * Adds a reprice if a callback is passed\n *\n * @param {Function} [done] callback\n * @public\n */\n\nPricingPromise.prototype.nodeify = function (done) {\n  if (type(done) === 'function') this.reprice();\n  return Promise.prototype.nodeify.apply(this, arguments);\n};\n",
    "deps": {
      "promise": "components/then-promise@6.0.0/index.js",
      "mixin": "components/kewah-mixin@0.1.0/index.js",
      "bind": "components/component-bind@0.0.1/index.js",
      "each": "components/component-each@0.2.3/index.js",
      "type": "components/component-type@1.0.0/index.js",
      "par": "components/pluma-par@0.3.0/dist/par.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js",
      "./": "lib/recurly/pricing/index.js"
    }
  },
  "components/pluma-par@0.3.0/dist/par.js": {
    "id": "components/pluma-par@0.3.0/dist/par.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "/*! par 0.3.0 Original author Alan Plum <me@pluma.io>. Released into the Public Domain under the UNLICENSE. @preserve */\nvar slice = Array.prototype.slice;\n\nfunction par(fn) {\n    var args0 = slice.call(arguments, 1);\n    return function() {\n        var argsN = slice.call(arguments, 0),\n            args = [];\n        args.push.apply(args, args0);\n        args.push.apply(args, argsN);\n        return fn.apply(this, args);\n    };\n}\n\nfunction rpartial(fn) {\n    var argsN = slice.call(arguments, 1);\n    return function() {\n        var args = slice.call(arguments, 0);\n        args.push.apply(args, argsN);\n        return fn.apply(this, args);\n    };\n}\n\npar.rpartial = rpartial;\npar.lpartial = par;\n\nmodule.exports = par;\n",
    "deps": {}
  },
  "components/then-promise@6.0.0/index.js": {
    "id": "components/then-promise@6.0.0/index.js",
    "type": "js",
    "mtime": 1410264721000,
    "src": "'use strict';\n\nmodule.exports = require('./lib/core.js')\nrequire('./lib/done.js')\nrequire('./lib/es6-extensions.js')\nrequire('./lib/node-extensions.js')",
    "deps": {
      "./lib/core.js": "components/then-promise@6.0.0/lib/core.js",
      "./lib/done.js": "components/then-promise@6.0.0/lib/done.js",
      "./lib/es6-extensions.js": "components/then-promise@6.0.0/lib/es6-extensions.js",
      "./lib/node-extensions.js": "components/then-promise@6.0.0/lib/node-extensions.js"
    }
  },
  "components/then-promise@6.0.0/lib/es6-extensions.js": {
    "id": "components/then-promise@6.0.0/lib/es6-extensions.js",
    "type": "js",
    "mtime": 1410264721000,
    "src": "'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nfunction ValuePromise(value) {\n  this.then = function (onFulfilled) {\n    if (typeof onFulfilled !== 'function') return this\n    return new Promise(function (resolve, reject) {\n      asap(function () {\n        try {\n          resolve(onFulfilled(value))\n        } catch (ex) {\n          reject(ex);\n        }\n      })\n    })\n  }\n}\nValuePromise.prototype = Promise.prototype\n\nvar TRUE = new ValuePromise(true)\nvar FALSE = new ValuePromise(false)\nvar NULL = new ValuePromise(null)\nvar UNDEFINED = new ValuePromise(undefined)\nvar ZERO = new ValuePromise(0)\nvar EMPTYSTRING = new ValuePromise('')\n\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value\n\n  if (value === null) return NULL\n  if (value === undefined) return UNDEFINED\n  if (value === true) return TRUE\n  if (value === false) return FALSE\n  if (value === 0) return ZERO\n  if (value === '') return EMPTYSTRING\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value))\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex)\n      })\n    }\n  }\n\n  return new ValuePromise(value)\n}\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr)\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    var remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { res(i, val) }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) { \n    reject(value);\n  });\n}\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) { \n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    })\n  });\n}\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n}\n",
    "deps": {
      "./core.js": "components/then-promise@6.0.0/lib/core.js",
      "asap": "components/johntron-asap@master/asap.js"
    }
  },
  "components/then-promise@6.0.0/lib/core.js": {
    "id": "components/then-promise@6.0.0/lib/core.js",
    "type": "js",
    "mtime": 1410264721000,
    "src": "'use strict';\n\nvar asap = require('asap')\n\nmodule.exports = Promise;\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')\n  if (typeof fn !== 'function') throw new TypeError('not a function')\n  var state = null\n  var value = null\n  var deferreds = []\n  var self = this\n\n  this.then = function(onFulfilled, onRejected) {\n    return new self.constructor(function(resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject))\n    })\n  }\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred)\n      return\n    }\n    asap(function() {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value)\n        return\n      }\n      var ret\n      try {\n        ret = cb(value)\n      }\n      catch (e) {\n        deferred.reject(e)\n        return\n      }\n      deferred.resolve(ret)\n    })\n  }\n\n  function resolve(newValue) {\n    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject)\n          return\n        }\n      }\n      state = true\n      value = newValue\n      finale()\n    } catch (e) { reject(e) }\n  }\n\n  function reject(newValue) {\n    state = false\n    value = newValue\n    finale()\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++)\n      handle(deferreds[i])\n    deferreds = null\n  }\n\n  doResolve(fn, resolve, reject)\n}\n\n\nfunction Handler(onFulfilled, onRejected, resolve, reject){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null\n  this.resolve = resolve\n  this.reject = reject\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n",
    "deps": {
      "asap": "components/johntron-asap@master/asap.js"
    }
  },
  "components/then-promise@6.0.0/lib/node-extensions.js": {
    "id": "components/then-promise@6.0.0/lib/node-extensions.js",
    "type": "js",
    "mtime": 1410264721000,
    "src": "'use strict';\n\n//This file contains then/promise specific extensions that are only useful for node.js interop\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity\n  return function () {\n    var self = this\n    var args = Array.prototype.slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop()\n      }\n      args.push(function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      })\n      fn.apply(self, args)\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null\n    var ctx = this\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx)\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) { reject(ex) })\n      } else {\n        asap(function () {\n          callback.call(ctx, ex)\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value)\n    })\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err)\n    })\n  })\n}\n",
    "deps": {
      "./core.js": "components/then-promise@6.0.0/lib/core.js",
      "asap": "components/johntron-asap@master/asap.js"
    }
  },
  "components/then-promise@6.0.0/lib/done.js": {
    "id": "components/then-promise@6.0.0/lib/done.js",
    "type": "js",
    "mtime": 1410264721000,
    "src": "'use strict';\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this\n  self.then(null, function (err) {\n    asap(function () {\n      throw err\n    })\n  })\n}",
    "deps": {
      "./core.js": "components/then-promise@6.0.0/lib/core.js",
      "asap": "components/johntron-asap@master/asap.js"
    }
  },
  "components/johntron-asap@master/asap.js": {
    "id": "components/johntron-asap@master/asap.js",
    "type": "js",
    "mtime": 1413253120000,
    "src": "\"use strict\";\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n// linked list of tasks (single, with head node)\nvar head = {task: void 0, next: null};\nvar tail = head;\nvar flushing = false;\nvar requestFlush = void 0;\nvar hasSetImmediate = typeof setImmediate === \"function\";\nvar domain;\n\nif (typeof global != 'undefined') {\n\t// Avoid shims from browserify.\n\t// The existence of `global` in browsers is guaranteed by browserify.\n\tvar process = global.process;\n}\n\n// Note that some fake-Node environments,\n// like the Mocha test runner, introduce a `process` global.\nvar isNodeJS = !!process && ({}).toString.call(process) === \"[object process]\";\n\nfunction flush() {\n    /* jshint loopfunc: true */\n\n    while (head.next) {\n        head = head.next;\n        var task = head.task;\n        head.task = void 0;\n\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them to interrupt flushing!\n\n                // Ensure continuation if an uncaught exception is suppressed\n                // listening process.on(\"uncaughtException\") or domain(\"error\").\n                requestFlush();\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n    }\n\n    flushing = false;\n}\n\nif (isNodeJS) {\n    // Node.js\n    requestFlush = function () {\n        // Ensure flushing is not bound to any domain.\n        var currentDomain = process.domain;\n        if (currentDomain) {\n            domain = domain || (1,require)(\"domain\");\n            domain.active = process.domain = null;\n        }\n\n        // Avoid tick recursion - use setImmediate if it exists.\n        if (flushing && hasSetImmediate) {\n            setImmediate(flush);\n        } else {\n            process.nextTick(flush);\n        }\n\n        if (currentDomain) {\n            domain.active = process.domain = currentDomain;\n        }\n    };\n\n} else if (hasSetImmediate) {\n    // In IE10, or https://github.com/NobleJS/setImmediate\n    requestFlush = function () {\n        setImmediate(flush);\n    };\n\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n    // working message ports the first time a page loads.\n    channel.port1.onmessage = function () {\n        requestFlush = requestPortFlush;\n        channel.port1.onmessage = flush;\n        flush();\n    };\n    var requestPortFlush = function () {\n        // Opera requires us to provide a message payload, regardless of\n        // whether we use it.\n        channel.port2.postMessage(0);\n    };\n    requestFlush = function () {\n        setTimeout(flush, 0);\n        requestPortFlush();\n    };\n\n} else {\n    // old browsers\n    requestFlush = function () {\n        setTimeout(flush, 0);\n    };\n}\n\nfunction asap(task) {\n    if (isNodeJS && process.domain) {\n        task = process.domain.bind(task);\n    }\n\n    tail = tail.next = {task: task, next: null};\n\n    if (!flushing) {\n        requestFlush();\n        flushing = true;\n    }\n};\n\nmodule.exports = asap;\n",
    "deps": {}
  },
  "lib/recurly/relay.js": {
    "id": "lib/recurly/relay.js",
    "type": "js",
    "mtime": 1413321377000,
    "src": "\n/*!\n * Module dependencies.\n */\n\nvar bind = require('bind');\nvar json = require('json');\nvar events = require('event');\nvar errors = require('../errors');\nvar debug = require('debug')('recurly:relay');\n\n/**\n * expose\n */\n\nmodule.exports = relay;\n\n/**\n * Relay mixin.\n *\n * Inspects the window for intent to relay a message,\n * then attempts to send it off. closes the window once\n * dispatched.\n *\n * @param {Function} done\n * @private\n */\n\nfunction relay (done) {\n  var self = this;\n\n  debug('relay');\n\n  if (false === this.configured) {\n    throw errors('not-configured');\n  }\n\n  events.bind(window, 'message', function listener (event) {\n    var data = json.parse(event.data);\n    var name = data.recurly_event;\n    var body = data.recurly_message;\n    var err = body.error ? errors('api-error', body.error) : null;\n    events.unbind(window, 'message', listener);\n    if (name) self.emit(name, err, body);\n    if (frame) document.body.removeChild(frame);\n  });\n\n  if ('documentMode' in document) {\n    var frame = document.createElement('iframe');\n    frame.width = frame.height = 0;\n    frame.src = this.url('/relay');\n    frame.name = 'recurly_relay';\n    frame.style.display = 'none';\n    frame.onload = bind(this, done);\n    document.body.appendChild(frame);\n  } else {\n    done();\n  }\n};\n",
    "deps": {
      "bind": "components/component-bind@0.0.1/index.js",
      "json": "components/component-json@0.0.2/index.js",
      "event": "components/component-event@0.1.3/index.js",
      "../errors": "lib/errors.js",
      "debug": "components/visionmedia-debug@0.8.1/debug.js"
    }
  }
}